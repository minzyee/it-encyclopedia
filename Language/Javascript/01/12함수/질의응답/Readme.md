# 기술면접 질문

## 09. 함수

### 1. 함수 호이스팅과 변수 호이스팅의 차이점을 설명해주세요.

<hr>

#### 대엽

- 함수 호이스팅

  - 함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 함수를 호출할 수 있음 (코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트 고유의 특징)

- 변수 호이스팅

  - 함수 표현식으로 함수를 정의하면 발생함

- var 키워드를 사용한 변수 선언문은 undefined로 초기화되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화됨. 따라서 var 키워드를 사용한 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefined로 평가되지만 함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다.

#### 민지

- 함수 호이스팅의 경우에는 함수의 선언 위치와 상관없이 코드 내 어느 곳에서든 호출이 가능합니다.
  이는 실행 전 초기화 단계에서 함수선언 방식으로 정의한 함수가 자바스크립트 엔진에 의해 실행 컨텍스트에 생성되었기 때문입니다.
  그렇기 때문에 함수 선언문 이전에 호출해도 함수 호이스팅에 의해 호출이 가능합니다.
- 변수 호이스팅의 경우 undefined로 초기화 됩니다. 때문에 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefined로 평가됩니다.
  함수 표현식도 변수에 할당되는 형태이기 때문에 함수 선언식과 다르게 함수 표현식도 변수 호이스팅과 동일하게 작동됩니다.

#### 다은

- 함수 호이스팅과 변수 호이스팅은 초기화 방식에서 차이를 확인할 수 있습니다. 함수와 변수 모두 선언 위치와 상관없이 각 스코프 내부의 어디에서나 호출이 가능하지만 변수는 undefined로 초기화되며, 함수는 함수 자체가 호이스팅되어 초기화되기 때문에 함수가 선언되기 전 함수를 실행 가능하다는 차이점이 있습니다. 이 때, 함수 선언식은 함수 전부가 호이스팅되지만, 함수 표현식은 undefined로 초기화되기 때문에 실행하면 타입 에러가 발생합니다.

#### 선아

- var 키워드를 사용해서 변수를 선언하면 undefined로 초기화됩니다. 그래서 선언문 이전에 변수를 참조하면 undefined로 평가됩니다. 그렇지만 함수는 함수 객체로 초기화되기 때문에 함수 선언문 이전에 호출이 가능합니다.

#### 광렬

- 두가지 모두 함수의 선언 위치와 상관없이 코드 내 어느곳에서든 호출이 가능하지만, 변수 호이스팅의 초기화는 undefined 입니다.

#### 풍윤

- 변수 선언은 런타임 이전에 실행되어 undefined로 초기화됩니다. 따라서 변수 선언 이전에 호출은 변수 호이스팅에 의해 반드시 undefined로 나옵니다. 반면에 함수 선언문으로 생성된 식별자는 함수 객체로 초기화됩니다. 따라서 함수 호이스팅에 의해 함수 선언문 이전에 함수 객체로 호출이 가능합니다.

<br>

### 2. ES6에서 화살표함수를 언제 사용하며, 왜 사용하나요?

<hr>

#### 대엽

- return 예약어 대신 암시적 반환을 통해 한줄 짜리 함수로 바꾸기 위해 사용함. (명시적 반환- 반환하려는 것을 직접 작성하는 것.) 코드의 간결성을 위하여 화살표 함수를 사용한다. 또한 다른 함수 내에서 화살표 함수를 사용하면 this를 재차 바인드하지 않으므로 클릭 핸들러와 같은 기능을 편리하게 구현할 수 있다.

#### 민지

- function 키워드 대신 ⇒ 화살표를 사용해 간략한 방법으로 함수를 선언할 수 있게 해주며, 함수 본연의 입출력 기능을 직관적으로 표현해주기 때문입니다.
- 파라미터가 하나뿐이거나 중괄호 내부의 코드가 하나이면 소괄호, 중괄호 모두 생략 가능하기 때문에 코드를 줄일 수 있습니다.
- 일반 함수 선언과 this 바인딩이 다르게 동작하는데, 일반 함수 내부에 있는 this는 함수가 쓰인 위치에 따라 this의 값이 바뀌는데, 화살표 함수 내부에서 사용된 this는 상위 스코프에 있는 this 값을 그대로 사용합니다.

#### 다은

- 화살표 함수를 사용하면 코드를 간결하게 할 수 있으며, 콜백 함수 내부의 this 문제를 해결하는 것이 가능합니다. 일반 함수에서는 함수의 호출 방식에 따라 this에 바인딩할 객체가 결정되기 때문에 콜백 함수의 this와 외부 함수의 this가 일치하지 않는 문제가 발생할 수도 있는데, 화살표 함수에서의 this는 상위 스코프의 this를 참조하기 때문에 화살표 함수를 유용하게 사용할 수 있습니다.

#### 선아

- 화살표 함수는 콜백함수로 주로 사용합니다. 그 이유는 코드가 간결하고, 화살표 함수의 this는 일반 함수와 달리 바인딩할 객체가 정적으로 결정 되는데, 항상 상위 스코프의 this를 가리키기 때문에 오류를 방지할 수 있습니다.

#### 광렬

- this 를 바인딩할때 주로 사용합니다.예를 들어 객체의 프로퍼티를 가리키고 싶다고 가정을 합니다. 이때 원래대로라면 콜백함수 내부의 this 는 전역객체 window 를 가리키게 되어 윈도우의 프로퍼티를 가리키게 되자만, 화살표 함수를 활용한다면 우리가 원하는 객체의 프로퍼티를 가리키게 할 수 있게됩니다.

#### 풍윤

- 자바스크립트를 프로그래밍할때 콜백을 담는 형태에 함수를 담는 형태가 있는데, 그럴 때 화살표 함수를 사용하면 코드를 줄이면서 직관적인 프로그래밍을 할 수 있습니다. 또한 따로 명시적으로 this 바인딩을 해주지 않아도, 상위 스코프의 this를 사용 할 수 있습니다. 따라서 콜백함수의 this와 외부함수의 this 간 불일치 문제를 해결할 수 있습니다.

<br>

### 3. 자바스크립트의 함수 호출 방법에는 무엇이 있을까요?

<hr>

#### 대엽

- 1. 함수 호출
- 2. 메서드 호출
  - 함수가 객체의 프로퍼티 값인 경우, 메서드로서 호출됨.
  - 메서드 내부의 this는 해당 메서드를 소유(호출)한 객체에 바인딩됨
- 3. 생성자 함수 호출
  - 일반 함수에 new 연산자를 붙이고 함수명의 첫글자를 대문자로 써서 호출하는 것
  - 생성자 함수를 호출하면 1) 빈 객체 생성 및 this 바인딩 -> 2) this를 통한 프로퍼티 생성 -> 3) 생성된 객체 반환의 과정으로 동작함
- 4. apply, call, bind 호출

  - apply, call, bind는 모든 함수의 프로토타입 객체인 Function.prototype 객체의 메서드이며, 이 메서드들은 this를 특정 객체에 명시적으로 바인딩한다.

- [참고자료](https://poiemaweb.com/js-this)

#### 민지

- 함수 호출 방식에는 가장 일반적으로 알고 있는 함수명 뒤에 괄호를 붙여 호출하는 방법과
  함수가 객체의 프로퍼티 값일 경우의 메서드 호출,
  기존 함수에 new 연산자를 붙여 호출하는 생성자 함수 호출,
  주어진 this 값과 배열로 제공되는 arguments 로 함수를 호출하는 apply 메서드와
  apply 메서드와 비슷하지만 인자를 배열로 전달하지 않고 인자 목록으로 직접 전달하는 call 메서드,
  호출되면 새로운 함수 생성하는 bind 메서드 호출 방식이 있습니다.

#### 다은

- 자바스크립트에서 함수를 호출하는 방식에는 4가지가 있습니다. function 키워드 형식의 일반적인 호출, 함수가 특정 객체의 프로퍼티로 존재할 때 객체의 프로퍼티로 호출하는 메소드로의 호출과 new 키워드를 사용한 생성자 함수로서의 호출과 apply, call을 활용하여 간접적으로 호출하는 방식이 있습니다.

#### 선아

- 식별자와 함수 호출 연산자인 소괄호를 사용해서 호출할 수 있습니다. 소괄호 내에는 0개 이상의 아규먼트를 쉼표로 구분해서 입력합니다. 그리고 함수를 호출하면 실행 흐름이 호출된 함수로 옮겨지고, 파라미터에 입력된 아규먼트가 순서대로 할당되고 문들이 실행됩니다.

#### 광렬

- 직접 함수 호출 과 간접 함수 호출이 있습니다.

#### 풍윤

- 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출합니다. 또한 메서드로의 함수 호출도 가능합니다. 이때, 프로퍼티의 접근 방식을 통해 함수를 호출합니다. 또한 'new 식별자()' 형태의 생성자 함수를 통해서도 함수 호출이 가능합니다. 마지막으로 apply와 call을 이용해서 함수를 호출하는 방법이 있습니다.

<br>

### 4. 표현식,선언식,화살표함수 사용법과 각 함수의 호이스팅에 관하여 설명해주세요.

<hr>

#### 대엽

- 함수 선언식은 function 키워드를 사용하며 함수명을 생략할 수 없으나, 표현식은 function 키워드를 사용하지 않고 변수에 할당을 하여 사용한다. 함수 선언문은 런타임 이전에 함수 객체로 초기화가 되어 함수 정의 전에 호출할 수 있으나 함수 표현식은 런타임 이전에 undefined로 초기화 되어있으므로 호이스팅이 발생하지 않는다. 그리고 화살표 함수 익명으로만 사용할 수 있으며 호이스팅 되지 않는다.

#### 민지

- 함수 선언식의 경우에는 function 키워드를 사용해 함수를 정의할 수 있으며,
  표현식과 화살표 함수는 변수에 함수를 할당하는 형식으로 작성합니다.
  이떄, 화살표 함수는 function 키워드 생략이 가능합니다.
  함수 선언문으로 함수 정의 시 런타임 이전에 함수 객체가 먼저 생성이 되기 때문에
  JS엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고, 생성된 함수 객체를 할당합니다.
  이는 즉, 런타임에 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태이기 때문에 에러를 발생하지 않고 함수 호출이 되며
  이런 현상을 함수의 호이스팅이라고 합니다.
  다만, 함수 표현식과 화살표 함수는 변수에 함수가 할당되는 형태이기 때문에
  일반적인 함수 호이스팅이 아닌 변수명을 통해 호출하는 변수 호이스팅의 형태로 발생하며, undefined로 초기화 되고
  해당 변수명 선언 이전에 호출할 경우 에러를 발생시킵니다.

#### 다은

- 함수 호이스팅은 변수 호이스팅과 다르게 함수 자체가 호이스팅된다는 차이점을 가지고 있지만, 표현식을 사용하여 정의하거나 변수에 저장될 수 있는 함수 표현식일 경우 변수명을 통해 호출되기 때문에 변수 호이스팅과 동일하게 작동하여 undefined로 초기화되며 함수 표현식보다 상단에서 호출할 경우 타입 에러가 발생합니다. function 키워드로 시작하는 함수인 함수 선언식은 함수 자체가 호이스팅되며, 함수가 선언되기 전 호출하여도 함수 선언식의 명령문이 실행됩니다. function 키워드와 중괄호를 생략하는 화살표 함수는 함수 표현식을 축약한 형태처럼도 보이며 함수 표현식과 동일하게 작동하여 함수 선언전에 호출하면 에러가 발생합니다.

#### 선아

- 함수 선언문은 함수 리터럴과 형태가 같고 호이스팅이 일어납니다. 함수 표현식은 주로 익명 함수로 사용하고 표현식인 문이기 때문에 변수에 할당하여 작성합니다. 그렇기 때문에 변수의 할당문인 함수 표현식의 함수 리터럴은 런타임에 평가되기 때문에 변수 호이스팅이 발생합니다. 화살표 함수는 function 키워드 대신 화살표 기호를 사용해 함수를 선언하고 항상 익명함수로 정의합니다. 호이스팅은 일어나지 않습니다.

#### 광렬

- 함수 선언식은 함수를 먼저 선언하는 방식으로 호이스팅의 영향을 받는다. 함수 표현식은 변수를 먼저 선언하는 방식으로 const 를 사용하며, 이는 호이스팅의 영향을 받지 않는다. 화살표함수는 함수 표현식과 유사하다. 다만, function을 생략하고 간결하게 사용할 수 있다. 또한 익명으로만 사용이 가능하며, 호이스팅의 영향을 받지 않는다.

#### 풍윤

- 함수 선언문은 함수 리터럴과 형태와 동일하게 정의하는 방식입니다. 함수 선언문 이전에 함수를 호출했을 경우 함수 리터럴과 동일한 객체를 런타임 이전에 평가하기 때문에 호출하는 함수의 결과를 출력하는 함수 호이스팅이 일어납니다. 함수 객체를 변수에 할당하여 정의하는 방식을 함수 표현식이라 하며, 이때 변수에 할당한 표현했기 때문에 함수 호이스팅이 아닌 변수 호이스팅이 발생하게 됩니다. 화살표 함수는 함수로 초기화되지 않기 때문에 호이스팅이 일어나지 않습니다.
